{
    "docs": [
        {
            "location": "/", 
            "text": "Gebiedsscan applicatie\n\n\nGetting Started\n\n\nThese instructions will get you a copy of the project up and running on your local machine for development and testing purposes. See deployment for notes on how to deploy the project on a live system.\n\n\nPrerequisites\n\n\nWhat things you need to install the software and how to install them\n\n Bitbucket access to repository (To be arranged via Proeftuin team).\n\n Have project repo downloaded to your machine.\n* Node js installed\n\n\nInstalling\n\n\nA step by step series of examples that tell you have to get a development env running\n\n\nInstall npm dependencies\n\n\nnpm install\n\n\n\n\nServe the application locally (live reload).\n\n\nnpm run dev\n\n\n\n\nThe app will be served on \nhttp://127.0.0.1:8000/\n\n\nDeployment\n\n\nTo build distribuition version run:\n\n\nnpm run build\n\n\n\n\nBuilt With\n\n\n\n\nVue JS\n - Javascript single page application framework.\n\n\nLeaflet\n - Interactive maps framework.\n\n\nES6\n - Built Using ES6 standards.\n\n\n\n\nProject layout\n\n\nsrc/\n    /assets\n        /img - images\n        /sass - stylesheets\n        /data - data files\n    /components - reusable VUE components\n    /GeoDataManager - Vanilla JS set of classes that handle the different data sources and map logic\n    /views - pages of the application per url route\n    app.js - main setup of the application, register reusable components here\n    routes.js - routes file with all frontend routes", 
            "title": "Startpagina"
        }, 
        {
            "location": "/#gebiedsscan-applicatie", 
            "text": "", 
            "title": "Gebiedsscan applicatie"
        }, 
        {
            "location": "/#getting-started", 
            "text": "These instructions will get you a copy of the project up and running on your local machine for development and testing purposes. See deployment for notes on how to deploy the project on a live system.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#prerequisites", 
            "text": "What things you need to install the software and how to install them  Bitbucket access to repository (To be arranged via Proeftuin team).  Have project repo downloaded to your machine.\n* Node js installed", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/#installing", 
            "text": "A step by step series of examples that tell you have to get a development env running  Install npm dependencies  npm install  Serve the application locally (live reload).  npm run dev  The app will be served on  http://127.0.0.1:8000/", 
            "title": "Installing"
        }, 
        {
            "location": "/#deployment", 
            "text": "To build distribuition version run:  npm run build", 
            "title": "Deployment"
        }, 
        {
            "location": "/#built-with", 
            "text": "Vue JS  - Javascript single page application framework.  Leaflet  - Interactive maps framework.  ES6  - Built Using ES6 standards.", 
            "title": "Built With"
        }, 
        {
            "location": "/#project-layout", 
            "text": "src/\n    /assets\n        /img - images\n        /sass - stylesheets\n        /data - data files\n    /components - reusable VUE components\n    /GeoDataManager - Vanilla JS set of classes that handle the different data sources and map logic\n    /views - pages of the application per url route\n    app.js - main setup of the application, register reusable components here\n    routes.js - routes file with all frontend routes", 
            "title": "Project layout"
        }, 
        {
            "location": "/overview/", 
            "text": "Introductie\n\n\nIn het kader van het toewerken naar de implementatie van de Omgevingswet en het Digitale Stelsel Omgevingswet stelt het Gebiedsscan pilot platform data beschikbaar voor gebiedsontwikkeldoeleinden. De Gebiedsscan is in deze context een uitkomst van een co-creatie hands-on leerervaring van gemeente Eindhoven, Utrecht en het Kadaster. Verschillende databronnen worden op de kaart aan elkaar gekoppeld waarmee informatie wordt toegevoed op de kaart. Het platform helpt het Kadaster en gemeenten in het kader van gebiedsontwikkeling. Initiatiefnemers worden hiermee ondersteund in de ori\u00ebntatiefase van een initiatief. Dit middels het beschikbaar stellen van relevante en inspirerende informatie op de kaart waaronder informatie over lopende initiatieven. Daarnaast kan men zelf een initiatief aanmaken en delen binnen dit platform.\n\n\nHet pilot platform beschikt over datasets zoals o.a. die van de Kamer van Koophandel en van enkele Landelijke voorzieningen zoals die van de BAG, BRT, Ruimtelijk Plannen, etc\u2026 Deze datasets zijn wijdverspreid en niet op een zingevende manier met elkaar in relatie gebracht. Deze applicatie tracht de data op een gebruiksvriendelijke manier gekoppeld te representeren.\n\n\nDatasets worden middels gemeenschappelijke data types waaronder bijvoorbeeld co\u00f6rdinaten, met elkaar in relatie gebracht. Om het platform op een effectieve manier te bedienen is er een \"slimme\" architectuur bedacht. Zie hiervoor het diagram en een verdere toelichting onder het kopje Gebiedsscan applicatie. Daarnaast is het hele ontwikkelproces gestandaardiseerd waardoor op een effectieve en snelle manier applicaties \u2013 gebaseerd op de onderliggende technologie/ framework - snel kunnen worden ingericht.\n\n\nOpen diagram full screen", 
            "title": "Introductie"
        }, 
        {
            "location": "/overview/#introductie", 
            "text": "In het kader van het toewerken naar de implementatie van de Omgevingswet en het Digitale Stelsel Omgevingswet stelt het Gebiedsscan pilot platform data beschikbaar voor gebiedsontwikkeldoeleinden. De Gebiedsscan is in deze context een uitkomst van een co-creatie hands-on leerervaring van gemeente Eindhoven, Utrecht en het Kadaster. Verschillende databronnen worden op de kaart aan elkaar gekoppeld waarmee informatie wordt toegevoed op de kaart. Het platform helpt het Kadaster en gemeenten in het kader van gebiedsontwikkeling. Initiatiefnemers worden hiermee ondersteund in de ori\u00ebntatiefase van een initiatief. Dit middels het beschikbaar stellen van relevante en inspirerende informatie op de kaart waaronder informatie over lopende initiatieven. Daarnaast kan men zelf een initiatief aanmaken en delen binnen dit platform.  Het pilot platform beschikt over datasets zoals o.a. die van de Kamer van Koophandel en van enkele Landelijke voorzieningen zoals die van de BAG, BRT, Ruimtelijk Plannen, etc\u2026 Deze datasets zijn wijdverspreid en niet op een zingevende manier met elkaar in relatie gebracht. Deze applicatie tracht de data op een gebruiksvriendelijke manier gekoppeld te representeren.  Datasets worden middels gemeenschappelijke data types waaronder bijvoorbeeld co\u00f6rdinaten, met elkaar in relatie gebracht. Om het platform op een effectieve manier te bedienen is er een \"slimme\" architectuur bedacht. Zie hiervoor het diagram en een verdere toelichting onder het kopje Gebiedsscan applicatie. Daarnaast is het hele ontwikkelproces gestandaardiseerd waardoor op een effectieve en snelle manier applicaties \u2013 gebaseerd op de onderliggende technologie/ framework - snel kunnen worden ingericht.  Open diagram full screen", 
            "title": "Introductie"
        }, 
        {
            "location": "/gebiedsscan-client/", 
            "text": "Gebiedsscan applicatie\n\n\nSince the retrieved data not always comes in the same format, it is a best practice to format it into a single unified data structure. Therefore, throughout the application, as a standard rule we only use leaflet layers. Any data source, (WMS features, JSON, GEOJSON and others) will be converted to a \nLeaflet GeoJson Layer\n. \n\n\nGeoDataManager\n\n\nThe GeoDataManager module, is a \"framework agnostic\" set of classes that help with the distributing of the logic and the retrieval of data from the different data sources.\n\n\nlet data = {Some GeoJson};\nL.geoJSON(data);\n\n\n\n\nEvery L.geoJSON instance is formated and declared with its respective event handlers. This allow us to interact with each of the datasources in a standarized way, and help us answer questions such as:\n\n\n\n\nRetrieve all the results within a certain polygon.\n\n\nRetrieve all the results intersecting a point.\n\n\netc...\n\n\n\n\n\n\nIn the above diagram you will find 3 main modules the \nMap\n, the \nManager\n and each of the layer providers that we are going to call \nProviders\n.\n\n\nManager\n\n\nThe \nManager\n class takes care of retrieving the data, adding and removing layers to the map, registering the different event handlers for each of the layers, filtering layers based on user interaction among other low level tasks that facilitate the development of the application. \n\n\nProviders\n\n\nThe \nProviders\n are a set of files following the following convention: DataSourceName + LayerProvider.js. E.g. \"BestemingsplanGebiedLayerProivder.js\". Each layer provider specifies how the manager will retrieve, format and render the data on the map. Therefore, you will find methods such as: getUnderPoint(geojsonPoint) or getUnderPolygon(geojsonPoint). That will specify how to get a feature under the given geometry, for a WMS layer we need to make a different api than to a sparql endpoint, and so on. \n\n\nMap\n\n\nThe \nMap\n module is just a VueJs component that creates an instance of the manager and initializes the Leaflet Map instance. \nIn the map component is where we hook the map events with the manager event handlers.\n\n\nExample\n\n\nIn the following example we illustrate what are the underlying steps on one of the use cases, which is, retrieving features under a geometry. \n\n\n\n\nHow to add a new data source?\n\n\nAdding a new data source is pretty straight forward, Just create the layer provider javascript file from the example and modify to fit the requirements, then, import and declare created class in the manager file. Lastly, indicate the manager to add layer to the mapp.\n\n\n1. Create Layer Provider\n\n\nimport LayerProvider from \n../LayerProvider\n;\nimport axios from \naxios\n;\n\nexport default class extends LayerProvider {\n\n    constructor(manager) {\n        super(manager);\n        this.name = 'Bag';\n        this.type = this.TYPE.TILES;\n        this.zIndex = 10;\n\n        //legend used in the UI\n        this.legend = { \n            pand: {\n                'backgroundColor': '#cccccc',\n                'border': '2px solid black'\n            }\n        }\n    }\n\n    render() {\n        this.visible = true;\n        this.layer = L.tileLayer.wms('https://geodata.nationaalgeoregister.nl/bag/wms', {\n            layers: 'pand',\n            format: 'image/png',\n            transparent: true\n        });\n        return this.layer;\n    }\n\n\n    //Specify how to get features under a point\n    getUnderPoint(point) {\n        return new Promise(resolve =\n {\n            axios.post('https://bag.basisregistraties.overheid.nl/api/v1/panden', {\n                'geometrie': {\n                    'contains': {'type': 'Point', 'coordinates': point}\n                }\n            }, {\n                headers: {\n                    'Accept': 'application/hal+json',\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': '7753828d-ece2-457e-8ac7-9bfd5b208ee4'\n                }\n            }).then(({data}) =\n {                \n                if (data._embedded.panden.length) {\n                    let geojson = {\n                        \ntype\n: \nFeature\n,\n                        \ngeometry\n: data._embedded.panden[0]._embedded.geometrie,\n                        \nproperties\n: data._embedded.panden[0]\n                    }\n                    let layer = L.geoJson(geojson);\n\n                    let style = {\n                        stroke: false,\n                        fill: true,\n                        fillOpacity: 0.6\n                    };\n                    layer.setStyle(style);\n\n                    resolve({\n                        source: this.name,\n                        label: 'Pand',\n                        layer: layer,\n                        data: data._embedded.panden\n                    })\n                }\n                else {\n                    resolve({});\n                }\n            });\n        });\n    }\n\n    //Specify how to get features under a polygon\n    getUnderPolygon(polygon) {\n        return new Promise(resolve =\n {\n            axios.post('https://bag.basisregistraties.overheid.nl/api/v1/panden', {\n                'geometrie': {\n                    'within': polygon\n                }\n            }, {\n                headers: {\n                    'Accept': 'application/hal+json',\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': '7753828d-ece2-457e-8ac7-9bfd5b208ee4'\n                }\n            }).then(({data}) =\n {\n                if (data._embedded.panden.length) {\n                    let geojson = {\n                        type: \nFeatureCollection\n,\n                        features: data._embedded.panden.map((item) =\n {\n                            let feature = {\n                                \ntype\n: \nFeature\n,\n                                \ngeometry\n: item._embedded.geometrie,\n                                \nproperties\n: item\n                            }\n                            return feature;\n                        })\n                    }\n\n                    let style = {\n                        stroke: false,\n                        fill: true,\n                        color: \n#00b703\n,\n                        fillOpacity: 0.6\n                    };\n\n                    let layer = L.geoJson(geojson, {style: style});\n\n                    resolve({\n                        source: this.name,\n                        label: 'Panden',\n                        layer: layer,\n                        data: data._embedded.panden\n                    })\n                }\n                else {\n                    resolve({});\n                }\n            });\n        });\n    }\n\n    //Specify what to return when layer is clicked.\n    clickEvent(event) {\n        return event.latlng;\n    }\n}\n\n\n\n\n\n\n2. Declare layer in manager\n\n\nIn the Manager.js file add in the \nproviderClasses\n array, the instance of the provider that has been created.\n\n\nimport BagLayerProivder from \n./Providers/BagLayerProivder\n;\n\nthis.providerClasses = [\n    BagLayerProivder,\n    BestemingsplanGebiedLayerProvider,\n    BRKLayerProivder\n]\n\n\n\n\n3. Indicate manager to add layer to map\n\n\nIn the HTML:\n\n\n\n\nBaseMap :bounds=\nbounds\n\n    :params=\nparams\n\n    @managerSetup=\nmanagerSetup\n\n    @BRTBackgroundClick=\nmapClicked\n\n\n/BaseMap\n\n\n\n\n\n\nIn the controller: \n\n\n{\n    //vue js data property\n    {\n        data() {\n            return {\n                params: {\n                    query: {},\n                    layers: {\n                        Bestemmingsplangebied: false\n                    },\n                    options: {\n                        flyToBoundsAnimated: false\n                    }\n                }\n            }\n        },\n        methods() {\n            managerSetup(managerReference) {\n                this.manager = managerReference;\n\n                this.manager.add([\n                    \nBag\n //Add the bag layer to the map\n                ]);\n            },\n            mapClicked() {\n                //do something when user clicks on the map\n            }\n        }\n    }\n}", 
            "title": "Gebiedsscan applicatie"
        }, 
        {
            "location": "/gebiedsscan-client/#gebiedsscan-applicatie", 
            "text": "Since the retrieved data not always comes in the same format, it is a best practice to format it into a single unified data structure. Therefore, throughout the application, as a standard rule we only use leaflet layers. Any data source, (WMS features, JSON, GEOJSON and others) will be converted to a  Leaflet GeoJson Layer .", 
            "title": "Gebiedsscan applicatie"
        }, 
        {
            "location": "/gebiedsscan-client/#geodatamanager", 
            "text": "The GeoDataManager module, is a \"framework agnostic\" set of classes that help with the distributing of the logic and the retrieval of data from the different data sources.  let data = {Some GeoJson};\nL.geoJSON(data);  Every L.geoJSON instance is formated and declared with its respective event handlers. This allow us to interact with each of the datasources in a standarized way, and help us answer questions such as:   Retrieve all the results within a certain polygon.  Retrieve all the results intersecting a point.  etc...    In the above diagram you will find 3 main modules the  Map , the  Manager  and each of the layer providers that we are going to call  Providers .", 
            "title": "GeoDataManager"
        }, 
        {
            "location": "/gebiedsscan-client/#manager", 
            "text": "The  Manager  class takes care of retrieving the data, adding and removing layers to the map, registering the different event handlers for each of the layers, filtering layers based on user interaction among other low level tasks that facilitate the development of the application.", 
            "title": "Manager"
        }, 
        {
            "location": "/gebiedsscan-client/#providers", 
            "text": "The  Providers  are a set of files following the following convention: DataSourceName + LayerProvider.js. E.g. \"BestemingsplanGebiedLayerProivder.js\". Each layer provider specifies how the manager will retrieve, format and render the data on the map. Therefore, you will find methods such as: getUnderPoint(geojsonPoint) or getUnderPolygon(geojsonPoint). That will specify how to get a feature under the given geometry, for a WMS layer we need to make a different api than to a sparql endpoint, and so on.", 
            "title": "Providers"
        }, 
        {
            "location": "/gebiedsscan-client/#map", 
            "text": "The  Map  module is just a VueJs component that creates an instance of the manager and initializes the Leaflet Map instance. \nIn the map component is where we hook the map events with the manager event handlers.", 
            "title": "Map"
        }, 
        {
            "location": "/gebiedsscan-client/#example", 
            "text": "In the following example we illustrate what are the underlying steps on one of the use cases, which is, retrieving features under a geometry.", 
            "title": "Example"
        }, 
        {
            "location": "/gebiedsscan-client/#how-to-add-a-new-data-source", 
            "text": "Adding a new data source is pretty straight forward, Just create the layer provider javascript file from the example and modify to fit the requirements, then, import and declare created class in the manager file. Lastly, indicate the manager to add layer to the mapp.", 
            "title": "How to add a new data source?"
        }, 
        {
            "location": "/gebiedsscan-client/#1-create-layer-provider", 
            "text": "import LayerProvider from  ../LayerProvider ;\nimport axios from  axios ;\n\nexport default class extends LayerProvider {\n\n    constructor(manager) {\n        super(manager);\n        this.name = 'Bag';\n        this.type = this.TYPE.TILES;\n        this.zIndex = 10;\n\n        //legend used in the UI\n        this.legend = { \n            pand: {\n                'backgroundColor': '#cccccc',\n                'border': '2px solid black'\n            }\n        }\n    }\n\n    render() {\n        this.visible = true;\n        this.layer = L.tileLayer.wms('https://geodata.nationaalgeoregister.nl/bag/wms', {\n            layers: 'pand',\n            format: 'image/png',\n            transparent: true\n        });\n        return this.layer;\n    }\n\n\n    //Specify how to get features under a point\n    getUnderPoint(point) {\n        return new Promise(resolve =  {\n            axios.post('https://bag.basisregistraties.overheid.nl/api/v1/panden', {\n                'geometrie': {\n                    'contains': {'type': 'Point', 'coordinates': point}\n                }\n            }, {\n                headers: {\n                    'Accept': 'application/hal+json',\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': '7753828d-ece2-457e-8ac7-9bfd5b208ee4'\n                }\n            }).then(({data}) =  {                \n                if (data._embedded.panden.length) {\n                    let geojson = {\n                         type :  Feature ,\n                         geometry : data._embedded.panden[0]._embedded.geometrie,\n                         properties : data._embedded.panden[0]\n                    }\n                    let layer = L.geoJson(geojson);\n\n                    let style = {\n                        stroke: false,\n                        fill: true,\n                        fillOpacity: 0.6\n                    };\n                    layer.setStyle(style);\n\n                    resolve({\n                        source: this.name,\n                        label: 'Pand',\n                        layer: layer,\n                        data: data._embedded.panden\n                    })\n                }\n                else {\n                    resolve({});\n                }\n            });\n        });\n    }\n\n    //Specify how to get features under a polygon\n    getUnderPolygon(polygon) {\n        return new Promise(resolve =  {\n            axios.post('https://bag.basisregistraties.overheid.nl/api/v1/panden', {\n                'geometrie': {\n                    'within': polygon\n                }\n            }, {\n                headers: {\n                    'Accept': 'application/hal+json',\n                    'Content-Type': 'application/json',\n                    'X-Api-Key': '7753828d-ece2-457e-8ac7-9bfd5b208ee4'\n                }\n            }).then(({data}) =  {\n                if (data._embedded.panden.length) {\n                    let geojson = {\n                        type:  FeatureCollection ,\n                        features: data._embedded.panden.map((item) =  {\n                            let feature = {\n                                 type :  Feature ,\n                                 geometry : item._embedded.geometrie,\n                                 properties : item\n                            }\n                            return feature;\n                        })\n                    }\n\n                    let style = {\n                        stroke: false,\n                        fill: true,\n                        color:  #00b703 ,\n                        fillOpacity: 0.6\n                    };\n\n                    let layer = L.geoJson(geojson, {style: style});\n\n                    resolve({\n                        source: this.name,\n                        label: 'Panden',\n                        layer: layer,\n                        data: data._embedded.panden\n                    })\n                }\n                else {\n                    resolve({});\n                }\n            });\n        });\n    }\n\n    //Specify what to return when layer is clicked.\n    clickEvent(event) {\n        return event.latlng;\n    }\n}", 
            "title": "1. Create Layer Provider"
        }, 
        {
            "location": "/gebiedsscan-client/#2-declare-layer-in-manager", 
            "text": "In the Manager.js file add in the  providerClasses  array, the instance of the provider that has been created.  import BagLayerProivder from  ./Providers/BagLayerProivder ;\n\nthis.providerClasses = [\n    BagLayerProivder,\n    BestemingsplanGebiedLayerProvider,\n    BRKLayerProivder\n]", 
            "title": "2. Declare layer in manager"
        }, 
        {
            "location": "/gebiedsscan-client/#3-indicate-manager-to-add-layer-to-map", 
            "text": "In the HTML:   BaseMap :bounds= bounds \n    :params= params \n    @managerSetup= managerSetup \n    @BRTBackgroundClick= mapClicked  /BaseMap   In the controller:   {\n    //vue js data property\n    {\n        data() {\n            return {\n                params: {\n                    query: {},\n                    layers: {\n                        Bestemmingsplangebied: false\n                    },\n                    options: {\n                        flyToBoundsAnimated: false\n                    }\n                }\n            }\n        },\n        methods() {\n            managerSetup(managerReference) {\n                this.manager = managerReference;\n\n                this.manager.add([\n                     Bag  //Add the bag layer to the map\n                ]);\n            },\n            mapClicked() {\n                //do something when user clicks on the map\n            }\n        }\n    }\n}", 
            "title": "3. Indicate manager to add layer to map"
        }, 
        {
            "location": "/conclusions/", 
            "text": "Conclusies en aanbevelingen\n\n\nHet pilot platform is ontwikkeld in het kader van een proeftuin waarmee het faciliteren van initiatieven t.b.v. gebiedsontwikkeling in de praktijk is getoetst. Wanneer het platform verder in de praktijk gebruikt zal worden door meerdere gebruikers is het raadzaam de volgende verbeteringen door te voeren. Hiermee wordt de applicatie ook schaalbaar voor de toekomst:\n\n\n\n\nEr wordt op dit moment in een aantal gevallen geen gebruik gemaakt van een geautomatiseerd proces om verschillende data sources te laden zoals bijvoorbeeld voor de bomen dataset van de gemeente Utrecht. Nieuwe brondata kan worden toegevoegd indien deze is voorzien van geometrische informatie waarmee de data op de kaart kan worden gekoppeld of wanneer de betreffende data over een adres component beschikt. T.b.v. automatisering van de verwerking van deze data in de applicatie is het aan te bevelen \u00e9\u00e9n van de volgende processen hiervoor in te richten:\n\n\nDe dataset kan middels een API worden ontsloten vanuit de bron. Meerdere dataformaten kunnen worden verwerkt waaronder bijv. JSON.\n\n\nDe data wordt geladen in het Kadaster Dataplatform als Linked Data waarmee de applicatie vervolgens dit platform kan bevragen middels het SPARQL endpoint.\n\n\nEen regelmatige PostGIS data dump wordt beschikbaar gesteld aan het applicatieteam.\n\n\nOverige formaten zoals, GeoJSON en met enkele aanpassingen zelfs CSV kunnen worden aangeboden aan het applicatieteam.\n\n\n\n\n\n\nDe data dumps kunnen geautomatiseerd worden, daarvoor kan een ETL worden vastgesteld zodat de gegevens geladen kunnen worden in PostGIS. Een gedetailleerde toelichting is hier terug te vinden: \nhttp://demo.semaku.com/gebiedsscan-docs/gebiedsscan-client/\n. Voor al deze varianten geldt dat het raadzaam is om eenmalig de data te laden en vervolgens duidelijke afspraken te maken omtrent update frequenties en processen.\n\n\nDe meeste offline/shapes/cvs data die verzameld is bevat een specifiek script welke is opgeschoond en getransformeerd in een werkende GeoJSON. Alle scripts werken met een ander formaat vanuit de input kant. De import van deze data kan worden verbeterd door de implementatie van een slimmere/effici\u00ebntere data tabel waarin primaire keys (geometrie/adres) automatisch worden geconverteerd naar JSON. Hiermee wordt een import proces aanzienlijk vereenvoudigd.\n\n\nOp dit moment worden de polygonen in de \u201cfrontend\u201d middels WMS (Web Map Service) MAP tiles (kaartlagen) te renderen getoond. Door deze activiteit te verplaatsen naar de \u201cbackend\u201d waar WMTS (Web Map Tile Service) files worden geladen wordt dit proces qua performance sterk verbeterd en wordt de de map tile (kaartlaag) binnen een gebruiksvriendelijke responsetijd in het platform weergegeven.\n\n\nAlle gebruikers hebben op dit moment gelijke rechten en er vindt geen onderscheid plaats tussen projecten, gebruikers en de makers van een initiatief. Functioneel zal goed nagedacht moeten worden over wie wat mag cre\u00ebren op de kaart aangezien de applicatie anders een grote \u201cbende\u201d kan worden. Dit vergt een verdere functionele analyse voordat dit op een waarde toevoegende manier kan functioneren. Momenteel kan iedereen een project aanmaken en zijn of haar eigen project aanpassen. Daarnaast is er een admin rol per gemeente beschikbaar die de projecten kan beheren en waar nodig aanpassen. Voor het platform in zijn totaliteit is een admin rol beschikbaar waarmee alle projecten kunnen worden aangepast. Er zal dan ook een duidelijk beheer van rollen, gebruikersgroepen ge\u00efmplementeerd moeten worden om effectief datatoegang te beheren.\n\n\nEen verdere verbetering van de UI en gebruikerservaring.", 
            "title": "Conclusies en aanbevelingen"
        }, 
        {
            "location": "/conclusions/#conclusies-en-aanbevelingen", 
            "text": "Het pilot platform is ontwikkeld in het kader van een proeftuin waarmee het faciliteren van initiatieven t.b.v. gebiedsontwikkeling in de praktijk is getoetst. Wanneer het platform verder in de praktijk gebruikt zal worden door meerdere gebruikers is het raadzaam de volgende verbeteringen door te voeren. Hiermee wordt de applicatie ook schaalbaar voor de toekomst:   Er wordt op dit moment in een aantal gevallen geen gebruik gemaakt van een geautomatiseerd proces om verschillende data sources te laden zoals bijvoorbeeld voor de bomen dataset van de gemeente Utrecht. Nieuwe brondata kan worden toegevoegd indien deze is voorzien van geometrische informatie waarmee de data op de kaart kan worden gekoppeld of wanneer de betreffende data over een adres component beschikt. T.b.v. automatisering van de verwerking van deze data in de applicatie is het aan te bevelen \u00e9\u00e9n van de volgende processen hiervoor in te richten:  De dataset kan middels een API worden ontsloten vanuit de bron. Meerdere dataformaten kunnen worden verwerkt waaronder bijv. JSON.  De data wordt geladen in het Kadaster Dataplatform als Linked Data waarmee de applicatie vervolgens dit platform kan bevragen middels het SPARQL endpoint.  Een regelmatige PostGIS data dump wordt beschikbaar gesteld aan het applicatieteam.  Overige formaten zoals, GeoJSON en met enkele aanpassingen zelfs CSV kunnen worden aangeboden aan het applicatieteam.    De data dumps kunnen geautomatiseerd worden, daarvoor kan een ETL worden vastgesteld zodat de gegevens geladen kunnen worden in PostGIS. Een gedetailleerde toelichting is hier terug te vinden:  http://demo.semaku.com/gebiedsscan-docs/gebiedsscan-client/ . Voor al deze varianten geldt dat het raadzaam is om eenmalig de data te laden en vervolgens duidelijke afspraken te maken omtrent update frequenties en processen.  De meeste offline/shapes/cvs data die verzameld is bevat een specifiek script welke is opgeschoond en getransformeerd in een werkende GeoJSON. Alle scripts werken met een ander formaat vanuit de input kant. De import van deze data kan worden verbeterd door de implementatie van een slimmere/effici\u00ebntere data tabel waarin primaire keys (geometrie/adres) automatisch worden geconverteerd naar JSON. Hiermee wordt een import proces aanzienlijk vereenvoudigd.  Op dit moment worden de polygonen in de \u201cfrontend\u201d middels WMS (Web Map Service) MAP tiles (kaartlagen) te renderen getoond. Door deze activiteit te verplaatsen naar de \u201cbackend\u201d waar WMTS (Web Map Tile Service) files worden geladen wordt dit proces qua performance sterk verbeterd en wordt de de map tile (kaartlaag) binnen een gebruiksvriendelijke responsetijd in het platform weergegeven.  Alle gebruikers hebben op dit moment gelijke rechten en er vindt geen onderscheid plaats tussen projecten, gebruikers en de makers van een initiatief. Functioneel zal goed nagedacht moeten worden over wie wat mag cre\u00ebren op de kaart aangezien de applicatie anders een grote \u201cbende\u201d kan worden. Dit vergt een verdere functionele analyse voordat dit op een waarde toevoegende manier kan functioneren. Momenteel kan iedereen een project aanmaken en zijn of haar eigen project aanpassen. Daarnaast is er een admin rol per gemeente beschikbaar die de projecten kan beheren en waar nodig aanpassen. Voor het platform in zijn totaliteit is een admin rol beschikbaar waarmee alle projecten kunnen worden aangepast. Er zal dan ook een duidelijk beheer van rollen, gebruikersgroepen ge\u00efmplementeerd moeten worden om effectief datatoegang te beheren.  Een verdere verbetering van de UI en gebruikerservaring.", 
            "title": "Conclusies en aanbevelingen"
        }
    ]
}